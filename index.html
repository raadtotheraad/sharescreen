<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Screen Share</title>
  <style>
    html, body {
      margin:0; padding:0;
      width:100vw; height:100vh;
      background:black; color:white;
      font-family:sans-serif;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    #overlay {
      position:absolute; z-index:2;
      text-align:center;
      backdrop-filter:blur(4px);
      background:rgba(0,0,0,0.6);
      padding:30px; border-radius:10px;
      display:flex; flex-direction:column; align-items:center;
    }
    #startBtn {
      font-size:1.5rem;
      padding:1rem 2rem;
      background:#2196F3; border:none; border-radius:8px;
      cursor:pointer; transition:0.2s;
      color:white; margin-bottom:1rem;
    }
    #startBtn:hover {
      background:#1976D2;
      transform:scale(1.05);
      box-shadow:0 0 30px rgba(0,150,255,0.4);
    }
    .disclaimer {
      font-size:1rem; color:#ccc;
      max-width:80%; line-height:1.4;
    }
    .disclaimer a {
      color:#5fc3ff; text-decoration:underline;
    }
    video {
      width:100%; height:100%; object-fit:contain;
      background:black; z-index:1;
    }
  </style>
</head>
<body>
  <div id="overlay" style="display:none;">
    <button id="startBtn">üé• Start Broadcast</button>
    <p class="disclaimer">
      ‚ö†Ô∏è Anyone with this link can view your broadcast:<br>
      <a href="https://raadtotheraad.github.io/sharescreen?role=viewer" target="_blank">
        raadtotheraad.github.io/sharescreen?role=viewer
      </a>
    </p>
  </div>
  <video id="video" autoplay playsinline muted></video>

  <script>
    const ws = new WebSocket('wss://sharescreenserver-toum.onrender.com');
    const role = new URLSearchParams(location.search).get('role');
    const clientId = crypto.randomUUID();
    const config = { iceServers:[{ urls:'stun:stun.l.google.com:19302' }] };

    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const video = document.getElementById('video');

    let localStream = null;
    const peerConnections = {};
    let peerConnection = null;
    let pendingCandidates = [];
    let broadcasterId = null;

    ws.onopen = () => {
      if (role === 'broadcaster') {
        ws.send(JSON.stringify({ type:'broadcaster', from:clientId }));
        overlay.style.display = 'flex';
        startBtn.onclick = startBroadcast;
      } else if (role === 'viewer') {
        ws.send(JSON.stringify({ type:'viewer', from:clientId }));
        startViewer();
      } else {
        alert('Use ?role=broadcaster or ?role=viewer');
      }
    };

    ws.onmessage = async ({ data }) => {
      const msg = JSON.parse(data);
      if (role === 'broadcaster') {
        if (msg.type === 'new-viewer') {
          const viewerId = msg.from;
          const pc = new RTCPeerConnection(config);
          peerConnections[viewerId] = pc;
          localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
          pc.onicecandidate = e => {
            if (e.candidate) ws.send(JSON.stringify({ type:'candidate', from:clientId, to:viewerId, candidate:e.candidate }));
          };
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          ws.send(JSON.stringify({ type:'offer', from:clientId, to:viewerId, sdp:offer.sdp }));
        }
        if (msg.type === 'answer') {
          const pc = peerConnections[msg.from];
          if (pc) await pc.setRemoteDescription(new RTCSessionDescription({ type:'answer', sdp:msg.sdp }));
        }
        if (msg.type === 'candidate') {
          const pc = peerConnections[msg.from];
          if (pc && pc.remoteDescription) await pc.addIceCandidate(msg.candidate);
        }
      }

      if (role === 'viewer') {
        if (msg.type === 'offer') {
          broadcasterId = msg.from;
          if (!peerConnection) createPeerConnection();
          await peerConnection.setRemoteDescription(new RTCSessionDescription({ type:'offer', sdp:msg.sdp }));
          for (const c of pendingCandidates) await peerConnection.addIceCandidate(c);
          pendingCandidates = [];
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          ws.send(JSON.stringify({ type:'answer', from:clientId, to:broadcasterId, sdp:answer.sdp }));
        }
        if (msg.type === 'candidate') {
          if (peerConnection?.remoteDescription) await peerConnection.addIceCandidate(msg.candidate);
          else pendingCandidates.push(msg.candidate);
        }
      }
    };

    async function startBroadcast() {
      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ video:true });
        video.srcObject = localStream;
        overlay.style.display = 'none';
        sendPixelData();
      } catch {
        alert('Permission denied or error');
      }
    }

    function sendPixelData() {
      // sample pixels to send separately if needed
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const w=64, h=36;
      canvas.width = w; canvas.height = h;
      setInterval(() => {
        ctx.drawImage(video, 0, 0, w, h);
        const img = ctx.getImageData(0,0,w,h).data;
        const arr = [];
        for (let i=0; i<img.length; i+=4) {
          arr.push(((1<<24)+(img[i]<<16)+(img[i+1]<<8)+img[i+2]).toString(16).slice(1));
        }
        ws.readyState===WebSocket.OPEN && ws.send(JSON.stringify({ type:'pixel-data', from:clientId, pixels:arr }));
      },1000);
    }

    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(config);
      peerConnection.ontrack = e => video.srcObject = e.streams[0];
      peerConnection.onicecandidate = e => {
        if (e.candidate && broadcasterId) {
          ws.send(JSON.stringify({ type:'candidate', from:clientId, to:broadcasterId, candidate:e.candidate }));
        }
      };
    }
    function startViewer() {
      createPeerConnection();
    }
  </script>
</body>
</html>
