<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Screen Share</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }

    #startBroadcastBtn {
      position: absolute;
      z-index: 2;
      padding: 16px 32px;
      font-size: 1.2em;
      color: white;
      background: red;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
  </style>
</head>
<body>
  <button id="startBroadcastBtn" style="display: none;">Start Broadcasting</button>
  <video id="video" autoplay playsinline></video>

  <script>
    const signalingUrl = 'wss://sharescreenserver-toum.onrender.com'; // Replace if needed
    const ws = new WebSocket(signalingUrl);
    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBroadcastBtn');
    const urlParams = new URLSearchParams(window.location.search);
    const role = urlParams.get('role'); // 'broadcaster' or 'viewer'
    const clientId = Math.random().toString(36).substring(2, 9);

    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let localStream;

    // Broadcaster keeps multiple connections:
    const peerConnections = {}; // viewerId -> RTCPeerConnection

    // Viewer single connection:
    let peerConnection;
    let pendingCandidates = [];
    let broadcasterId = null;

    ws.onopen = () => {
      console.log('[WS] Connected');
      if (role === 'broadcaster') {
        startBtn.style.display = 'block';
        startBtn.onclick = async () => {
          ws.send(JSON.stringify({ type: 'broadcaster', from: clientId }));
          startBtn.style.display = 'none';
          await startBroadcast();
        };
      } else if (role === 'viewer') {
        ws.send(JSON.stringify({ type: 'viewer', from: clientId }));
        startViewing();
      } else {
        alert('Specify ?role=broadcaster or ?role=viewer in the URL.');
      }
    };

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data);
      console.log('[WS] Received:', data);

      if (role === 'broadcaster') {
        if (data.type === 'new-viewer') {
          const viewerId = data.id;
          console.log('[Broadcaster] New viewer:', viewerId);

          // Create new RTCPeerConnection for this viewer
          const pc = new RTCPeerConnection(config);
          peerConnections[viewerId] = pc;

          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

          pc.onicecandidate = (e) => {
            if (e.candidate) {
              ws.send(JSON.stringify({
                type: 'candidate',
                candidate: e.candidate,
                from: clientId,
                to: viewerId
              }));
            }
          };

          try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            ws.send(JSON.stringify({
              type: 'offer',
              sdp: offer.sdp,
              from: clientId,
              to: viewerId
            }));
          } catch (err) {
            console.error('[Broadcaster] Error creating offer for viewer:', viewerId, err);
          }
        }
        else if (data.type === 'answer') {
          const viewerId = data.from;
          const pc = peerConnections[viewerId];
          if (pc) {
            try {
              await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: data.sdp }));
              console.log('[Broadcaster] Set remote description from viewer:', viewerId);
            } catch (err) {
              console.error('[Broadcaster] Failed to set remote description for viewer:', viewerId, err);
            }
          }
        }
        else if (data.type === 'candidate') {
          const viewerId = data.from;
          const pc = peerConnections[viewerId];
          if (pc && pc.remoteDescription) {
            try {
              await pc.addIceCandidate(data.candidate);
              console.log('[Broadcaster] Added ICE candidate for viewer:', viewerId);
            } catch (e) {
              console.error('[Broadcaster] Failed to add ICE candidate:', e);
            }
          } else {
            console.log('[Broadcaster] ICE candidate received before remote description for viewer:', viewerId);
          }
        }
      }

      if (role === 'viewer') {
        if (data.type === 'offer') {
          broadcasterId = data.from;
          if (!peerConnection) createPeerConnection();

          try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: data.sdp }));
            console.log('[Viewer] Remote description set');
          } catch (err) {
            console.error('[Viewer] Failed to set remote description:', err);
          }

          for (const c of pendingCandidates) {
            try {
              await peerConnection.addIceCandidate(c);
              console.log('[Viewer] Added queued ICE candidate');
            } catch (e) {
              console.error('[Viewer] Failed to add queued ICE candidate:', e);
            }
          }
          pendingCandidates = [];

          try {
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('[Viewer] Created and set local answer');

            ws.send(JSON.stringify({
              type: 'answer',
              sdp: answer.sdp,
              from: clientId,
              to: broadcasterId
            }));
            console.log('[Viewer] Sent answer');
          } catch (err) {
            console.error('[Viewer] Error during answer creation or sending:', err);
          }
        }
        else if (data.type === 'candidate') {
          if (peerConnection && peerConnection.remoteDescription) {
            try {
              await peerConnection.addIceCandidate(data.candidate);
              console.log('[Viewer] Added ICE candidate');
            } catch (e) {
              console.error('[Viewer] Failed to add ICE candidate:', e);
            }
          } else {
            console.log('[Viewer] Queueing ICE candidate until remote description is set');
            pendingCandidates.push(data.candidate);
          }
        }
      }
    };

    async function startBroadcast() {
      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        video.srcObject = localStream;
        console.log('[Broadcaster] Screen sharing started');
      } catch (err) {
        alert('Failed to share screen: ' + err.message);
      }
    }

    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(config);

      peerConnection.ontrack = event => {
        console.log('[Viewer] Stream received', event.streams);
        video.srcObject = event.streams[0];
        video.muted = true;
        video.play().catch(e => console.warn('[Viewer] Autoplay blocked:', e));
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate && broadcasterId) {
          console.log('[Viewer] Sending ICE candidate to broadcaster:', e.candidate);
          ws.send(JSON.stringify({
            type: 'candidate',
            candidate: e.candidate,
            from: clientId,
            to: broadcasterId
          }));
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('[Viewer] Connection state:', peerConnection.connectionState);
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log('[Viewer] ICE connection state:', peerConnection.iceConnectionState);
      };
    }

    function startViewing() {
      createPeerConnection();
    }
  </script>
</body>
</html>
