<!DOCTYPE html>
<html>
<head>
  <title>Screen Share</title>
  <meta charset="UTF-8" />
</head>
<body style="margin:0;">
  <video id="video" autoplay playsinline style="width:100vw; height:100vh; object-fit:contain;"></video>

  <script>
    window.onload = () => {
      const ws = new WebSocket('wss://sharescreenserver-toum.onrender.com');
      const video = document.getElementById('video');
      const urlParams = new URLSearchParams(window.location.search);
      const role = urlParams.get('role'); // 'broadcaster' or 'viewer'
      const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

      let localStream;
      let peerConnection;
      let pendingCandidates = [];

      ws.onopen = () => {
        console.log('[WS] Connected');
        if (role === 'broadcaster') {
          ws.send(JSON.stringify({ type: 'broadcaster' }));
          startBroadcast();
        } else {
          ws.send(JSON.stringify({ type: 'viewer' }));
          startViewing();
        }
      };

      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        console.log('[WS] Received:', data);

        if (role === 'broadcaster') {
          if (data.type === 'new-viewer') {
            // When a new viewer arrives, create peerConnection and send offer
            const viewerId = data.id;
            if (!peerConnection) {
              console.warn('Broadcaster: no peerConnection instance for viewers; implement multi-viewer support if needed');
              // For multi-viewer you’d want one RTCPeerConnection per viewer.
            }
          }
          if (data.type === 'answer') {
            if (peerConnection) {
              await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: data.sdp }));
            }
          }
          if (data.type === 'candidate') {
            if (peerConnection) {
              try {
                await peerConnection.addIceCandidate(data.candidate);
              } catch (e) {
                console.error('Broadcaster failed to add ICE candidate:', e);
              }
            }
          }
          return;
        }

        // Viewer message handling:
        if (data.type === 'offer') {
          if (!peerConnection) {
            createPeerConnection();
          }
          await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: data.sdp }));

          // Add any queued ICE candidates now
          for (const candidate of pendingCandidates) {
            try {
              await peerConnection.addIceCandidate(candidate);
            } catch (e) {
              console.error('Error adding queued candidate:', e);
            }
          }
          pendingCandidates = [];

          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          ws.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
          console.log('[Viewer] Sent answer');
        } else if (data.type === 'candidate') {
          const candidate = data.candidate;
          if (peerConnection && peerConnection.remoteDescription && peerConnection.remoteDescription.type) {
            try {
              await peerConnection.addIceCandidate(candidate);
            } catch (e) {
              console.error('Failed to add ICE candidate:', e);
            }
          } else {
            // Remote description not set yet, queue candidate
            pendingCandidates.push(candidate);
          }
        }
      };

      async function startBroadcast() {
        try {
          localStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          video.srcObject = localStream;

          peerConnection = new RTCPeerConnection(config);

          localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

          peerConnection.onicecandidate = e => {
            if (e.candidate) {
              ws.send(JSON.stringify({ type: 'candidate', candidate: e.candidate }));
            }
          };

          // NOTE: You’ll need to implement multi-viewer support in the signaling server and client here.
          console.log('[Broadcaster] Screen sharing started');
        } catch (err) {
          alert('Failed to share screen: ' + err.message);
        }
      }

      function createPeerConnection() {
        peerConnection = new RTCPeerConnection(config);

        peerConnection.ontrack = event => {
          console.log('[Viewer] Received track');
          video.srcObject = event.streams[0];
        };

        peerConnection.onicecandidate = e => {
          if (e.candidate) {
            ws.send(JSON.stringify({ type: 'candidate', candidate: e.candidate }));
          }
        };
      }

      function startViewing() {
        createPeerConnection();
      }
    };
  </script>
</body>
</html>
