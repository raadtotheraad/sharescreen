<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Screen Share</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      color: white;
      font-family: Arial, sans-serif;
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }
    #ui {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 25px 35px;
      border-radius: 14px;
      backdrop-filter: blur(6px);
      max-width: 320px;
      user-select: none;
      z-index: 10;
    }
    #startBtn {
      margin-top: 20px;
      padding: 10px 24px;
      font-size: 18px;
      border-radius: 8px;
      border: none;
      background: #1e90ff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      backdrop-filter: none;
      position: relative;
      overflow: hidden;
    }
    #startBtn:hover {
      background-color: #63b3ff;
      box-shadow: 0 0 15px rgba(99, 179, 255, 0.7);
      backdrop-filter: blur(5px);
    }
    #robloxCheckbox {
      margin-top: 15px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      user-select: none;
    }
    #disclaimer {
      margin-top: 22px;
      font-size: 13px;
      line-height: 1.3;
      color: #ccc;
    }
    #disclaimer a {
      color: #63b3ff;
      text-decoration: none;
    }
    #disclaimer a:hover {
      text-decoration: underline;
    }
    #waitingText p {
      margin: 10px 0;
      font-size: 16px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>

  <div id="ui">
    <!-- UI content will be injected dynamically -->
  </div>

  <script>
    const signalingUrl = 'wss://sharescreenserver-toum.onrender.com';
    const ws = new WebSocket(signalingUrl);
    const video = document.getElementById('video');
    const ui = document.getElementById('ui');
    const urlParams = new URLSearchParams(window.location.search);
    const role = urlParams.get('role');
    const clientId = crypto.randomUUID();

    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let localStream = null;
    const peerConnections = {}; // broadcaster: viewerId -> RTCPeerConnection
    let peerConnection = null; // viewer
    let pendingCandidates = [];
    let broadcasterId = null;

    ws.onopen = () => {
      if (role === 'broadcaster') {
        ws.send(JSON.stringify({ type: 'broadcaster', from: clientId }));
        setupBroadcasterUI();
      } else if (role === 'viewer') {
        ws.send(JSON.stringify({ type: 'viewer', from: clientId }));
        setupViewerUI();
        startViewing();
      } else {
        alert('Missing ?role=broadcaster or ?role=viewer in URL');
      }
    };

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data);

      if (role === 'broadcaster') {
        if (data.type === 'new-viewer') {
          const viewerId = data.from;
          const pc = new RTCPeerConnection(config);
          peerConnections[viewerId] = pc;

          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

          pc.onicecandidate = e => {
            if (e.candidate) {
              ws.send(JSON.stringify({
                type: 'candidate',
                from: clientId,
                to: viewerId,
                candidate: e.candidate
              }));
            }
          };

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          ws.send(JSON.stringify({
            type: 'offer',
            from: clientId,
            to: viewerId,
            sdp: offer.sdp
          }));
        }

        if (data.type === 'answer') {
          const pc = peerConnections[data.from];
          if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: data.sdp }));
          }
        }

        if (data.type === 'candidate') {
          const pc = peerConnections[data.from];
          if (pc && pc.remoteDescription) {
            await pc.addIceCandidate(data.candidate);
          }
        }
      }

      if (role === 'viewer') {
        if (data.type === 'offer') {
          broadcasterId = data.from;
          if (!peerConnection) createPeerConnection();

          await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: data.sdp }));

          for (const c of pendingCandidates) await peerConnection.addIceCandidate(c);
          pendingCandidates = [];

          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          ws.send(JSON.stringify({
            type: 'answer',
            from: clientId,
            to: broadcasterId,
            sdp: answer.sdp
          }));

          // Hide waiting UI
          ui.style.display = 'none';
        }

        if (data.type === 'candidate') {
          if (peerConnection?.remoteDescription) {
            await peerConnection.addIceCandidate(data.candidate);
          } else {
            pendingCandidates.push(data.candidate);
          }
        }
      }
    };

    // --- Broadcaster UI Setup ---
    function setupBroadcasterUI() {
      ui.innerHTML = `
        <label id="robloxCheckbox">
          <input type="checkbox" id="allowRoblox" />
          Allow streaming to Roblox
        </label>
        <button id="startBtn">Start Broadcast</button>
        <div id="disclaimer">
          <p>Anyone with this link can watch your broadcast:</p>
          <a href="https://raadtotheraad.github.io/sharescreen?role=viewer" target="_blank" rel="noopener noreferrer">
            https://raadtotheraad.github.io/sharescreen?role=viewer
          </a>
        </div>
      `;

      const startBtn = document.getElementById('startBtn');
      startBtn.addEventListener('click', async () => {
        startBtn.disabled = true;
        const allowRoblox = document.getElementById('allowRoblox').checked;
        try {
          await startBroadcast(allowRoblox);
          ui.style.display = 'none'; // Hide UI once broadcasting starts
        } catch (err) {
          console.error(err);
          alert('Failed to start broadcast or permission denied.');
          startBtn.disabled = false;
        }
      });
    }

    // --- Start Broadcasting ---
    async function startBroadcast(allowRoblox) {
      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        video.srcObject = localStream;

        // Inform server (and Roblox) if streaming to Roblox is allowed
        ws.send(JSON.stringify({
          type: 'roblox-permission',
          from: clientId,
          allowed: allowRoblox
        }));

      } catch (err) {
        throw err;
      }
    }

    // --- Viewer UI Setup ---
    function setupViewerUI() {
      ui.innerHTML = `
        <div id="waitingText">
          <p><strong>Waiting for broadcaster connection...</strong></p>
          <p>If it doesn't happen after a few seconds,<br/>please refresh the page.</p>
        </div>
      `;
      ui.style.display = 'block';
    }

    // --- Viewer PeerConnection ---
    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(config);

      peerConnection.ontrack = event => {
        const stream = event.streams[0];
        video.srcObject = stream;
      };

      peerConnection.onicecandidate = e => {
        if (e.candidate && broadcasterId) {
          ws.send(JSON.stringify({
            type: 'candidate',
            from: clientId,
            to: broadcasterId,
            candidate: e.candidate
          }));
        }
      };
    }

    function startViewing() {
      createPeerConnection();
    }
  </script>
</body>
</html>
