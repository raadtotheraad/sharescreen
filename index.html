<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Screen Share</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      color: white;
      font-family: Arial, sans-serif;
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }
    #ui {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px 30px;
      border-radius: 12px;
      backdrop-filter: blur(5px);
    }
    #broadcastBtn {
      background: #1e90ff;
      border: none;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: bold;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.3s ease;
      margin-bottom: 15px;
    }
    #broadcastBtn:hover {
      background: #63b3ff;
      transform: scale(1.05);
      backdrop-filter: blur(8px);
    }
    label {
      font-size: 16px;
      display: block;
      cursor: pointer;
      user-select: none;
      margin-bottom: 10px;
    }
    input[type="checkbox"] {
      margin-right: 10px;
      transform: scale(1.3);
      vertical-align: middle;
      cursor: pointer;
    }
    a {
      color: #63b3ff;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    #disclaimer {
      margin-top: 12px;
      font-size: 14px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>

  <div id="ui">
    <button id="broadcastBtn">Start Broadcast</button>
    <label>
      <input type="checkbox" id="robloxStream" />
      Also stream to Roblox
    </label>
    <div id="disclaimer">
      Anyone with this link can watch your broadcast:<br/>
      <a href="https://raadtotheraad.github.io/sharescreen?role=viewer" target="_blank" rel="noopener noreferrer">
        https://raadtotheraad.github.io/sharescreen?role=viewer
      </a>
    </div>
  </div>

  <script>
    const signalingUrl = 'wss://sharescreenserver-toum.onrender.com';
    const ws = new WebSocket(signalingUrl);
    const video = document.getElementById('video');
    const ui = document.getElementById('ui');
    const broadcastBtn = document.getElementById('broadcastBtn');
    const robloxCheckbox = document.getElementById('robloxStream');
    const urlParams = new URLSearchParams(window.location.search);
    const role = urlParams.get('role');
    const clientId = crypto.randomUUID();

    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let localStream = null;
    const peerConnections = {}; // broadcaster: viewerId -> RTCPeerConnection

    ws.onopen = () => {
      if (role === 'broadcaster') {
        ws.send(JSON.stringify({ type: 'broadcaster', from: clientId }));
        // Wait for user to click start broadcast
      } else {
        alert('This page is for broadcasters only. Use ?role=broadcaster in URL.');
      }
    };

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data);
      if (role === 'broadcaster') {
        if (data.type === 'new-viewer') {
          const viewerId = data.from;
          const pc = new RTCPeerConnection(config);
          peerConnections[viewerId] = pc;

          localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

          pc.onicecandidate = e => {
            if (e.candidate) {
              ws.send(JSON.stringify({
                type: 'candidate',
                from: clientId,
                to: viewerId,
                candidate: e.candidate
              }));
            }
          };

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          ws.send(JSON.stringify({
            type: 'offer',
            from: clientId,
            to: viewerId,
            sdp: offer.sdp
          }));
        }

        if (data.type === 'answer') {
          const pc = peerConnections[data.from];
          if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: data.sdp }));
          }
        }

        if (data.type === 'candidate') {
          const pc = peerConnections[data.from];
          if (pc && pc.remoteDescription) {
            await pc.addIceCandidate(data.candidate);
          }
        }
      }
    };

    broadcastBtn.onclick = async () => {
      broadcastBtn.disabled = true;
      broadcastBtn.textContent = 'Starting Broadcast...';

      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        video.srcObject = localStream;

        // Hide UI once broadcasting starts
        ui.style.display = 'none';

        // If Roblox streaming is enabled, start sending pixel data:
        if (robloxCheckbox.checked) {
          startSendingPixelData();
        }
      } catch (err) {
        alert('Screen share permission denied or error occurred.');
        console.error('Error starting screen share:', err);
        broadcastBtn.disabled = false;
        broadcastBtn.textContent = 'Start Broadcast';
      }
    };

    function startSendingPixelData() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const width = 64;
      const height = 36;
      canvas.width = width;
      canvas.height = height;

      function sendPixels() {
        if (ws.readyState !== WebSocket.OPEN) return;
        ctx.drawImage(video, 0, 0, width, height);
        const imgData = ctx.getImageData(0, 0, width, height);
        const pixels = [];
        for (let i = 0; i < imgData.data.length; i += 4) {
          const r = imgData.data[i];
          const g = imgData.data[i + 1];
          const b = imgData.data[i + 2];
          const hex = ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
          pixels.push(hex);
        }
        ws.send(JSON.stringify({
          type: 'pixel-data',
          from: clientId,
          pixels
        }));
      }

      setInterval(sendPixels, 1000);
    }
  </script>
</body>
</html>
